use sqlx::{mysql::MySqlPool, FromRow};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct Exploitation {
    pub id: i32,
    pub type_exploitation_id: i32,
    pub domaine_id: i32,
    pub nom_exploitation: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateExploitation {
    pub type_exploitation_id: i32,
    pub domaine_id: i32,
    pub nom_exploitation: String,
}

impl Exploitation {
    // Ajouter une exploitation
    pub async fn create(
        pool: &MySqlPool,
        type_exploitation_id: i32,
        domaine_id: i32,
        nom_exploitation: String,
    ) -> Result<Self, sqlx::Error> {
        let insert_result = sqlx::query!(
            r#"
            INSERT INTO exploitations (type_exploitation_id, domaine_id, nom_exploitation)
            VALUES (?, ?, ?)
            "#,
            type_exploitation_id,
            domaine_id,
            nom_exploitation
        )
        .execute(pool)
        .await?;

        let last_id = insert_result.last_insert_id() as i32;

        Ok(Exploitation {
            id: last_id,
            type_exploitation_id,
            domaine_id,
            nom_exploitation,
        })
    }

    // Récupérer toutes les exploitations
    pub async fn get_all(pool: &MySqlPool) -> Result<Vec<Self>, sqlx::Error> {
        let exploitations = sqlx::query_as!(
            Exploitation,
            r#"
            SELECT id, type_exploitation_id, domaine_id, nom_exploitation
            FROM exploitations
            "#
        )
        .fetch_all(pool)
        .await?;

        Ok(exploitations)
    }

    // Supprimer une exploitation par ID
    pub async fn delete(pool: &MySqlPool, id: i32) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            DELETE FROM exploitations WHERE id = ?
            "#,
            id
        )
        .execute(pool)
        .await?;
        Ok(())
    }

    // Récupérer toutes les exploitations pour un domaine donné
    pub async fn get_by_domaine_id(pool: &MySqlPool, domaine_id: i32) -> Result<Vec<Self>, sqlx::Error> {
        let exploitations = sqlx::query_as!(
            Exploitation,
            r#"
            SELECT id, type_exploitation_id, domaine_id, nom_exploitation
            FROM exploitations
            WHERE domaine_id = ?
            "#,
            domaine_id
        )
        .fetch_all(pool)
        .await?;

        Ok(exploitations)
    }
}
